#include "STDInclude.hpp"

#include "Network/Address.hpp"
#include "Network/Sniffer.hpp"

namespace Network
{
	void Sniffer::PacketHandler(u_char *param, const pcap_pkthdr* header, const u_char *pktData)
	{
		Sniffer::Context* context = Sniffer::Context::From(param);
		context->sniffer->packetHandler(context->handle, header, pktData);
	}

	void Sniffer::packetHandler(pcap_t *handle, const pcap_pkthdr* header, const u_char *pktData)
	{
		const ipHeader* ih = nullptr;

		int dlt = pcap_datalink(handle);
		if (dlt == DLT_NULL)
		{
			const loopbackHeader* protoHeader = reinterpret_cast<const loopbackHeader*>(pktData);
			if (protoHeader->type == 2) // IPv4
			{
				ih = reinterpret_cast<const ipHeader *>(pktData + sizeof(loopbackHeader));
			}
		}
		else if (dlt == DLT_EN10MB)
		{
			const ethHeader* protoHeader = reinterpret_cast<const ethHeader*>(pktData);
			if (protoHeader->type == 8) // IPv4
			{
				ih = reinterpret_cast<const ipHeader *>(pktData + sizeof(ethHeader));
			}
		}

		// Invalid data link type, ip version or protocol
		if (!ih || ih->proto != IPPROTO_UDP) return;

		u_int ipLen = (ih->ver_ihl & 0xF) * 4;
		udpHeader* uh = reinterpret_cast<udpHeader *>(PBYTE(ih) + ipLen);

		Network::Address source;
		source.setIPv4(ih->saddr);
		source.setPort(ntohs(uh->sport));

		Network::Address target;
		target.setIPv4(ih->daddr);
		target.setPort(ntohs(uh->dport));

		uint32_t len = std::min(header->caplen, header->len);
		LPSTR dataPtr = LPSTR(uh) + sizeof(udpHeader);
		len -= dataPtr - LPSTR(pktData);

		std::string_view rawData(LPSTR(pktData), std::min(header->caplen, header->len));
		std::string_view data(dataPtr, len);

		if (this->callback)
		{
			Network::Interface networkIf;
			networkIf.handle = handle;

			this->callback(this, &networkIf, source, target, data, rawData);
		}
	}

	void Sniffer::openAllInterfaces()
	{
		pcap_if_t *alldevs;
		char errbuf[PCAP_ERRBUF_SIZE];
		if (pcap_findalldevs(&alldevs, errbuf)) return;

		for (pcap_if_t* networkIf = alldevs; networkIf; networkIf = networkIf->next)
		{
			this->openInterface(networkIf->name);
		}

		pcap_freealldevs(alldevs);
	}

	bool Sniffer::openInterface(char* name)
	{
		bpf_u_int32 mask, net;
		char errbuf[PCAP_ERRBUF_SIZE];
		if (pcap_lookupnet(name, &net, &mask, errbuf) == -1) return false;

		pcap_t* handle = pcap_open_live(name, 65536, 1, 1000, errbuf);
		if (handle)
		{
			bpf_program filter;
			if (pcap_compile(handle, &filter, "udp", 0, net) != -1 &&
				pcap_setfilter(handle, &filter) != -1 &&
				(pcap_datalink(handle) | 1) == DLT_EN10MB) // loopback and eth
			{
				std::lock_guard<std::mutex> _(this->mutex);
				this->interfaces.push_back({ handle, name, std::thread([this, handle]
				{
					Sniffer::Context context;
					context.handle = handle;
					context.sniffer = this;

					//printf("Starting loop on thread %X\n", GetCurrentThreadId());
					pcap_loop(handle, 0, Sniffer::PacketHandler, context.as<u_char>());
					//printf("Stopping loop on thread %X\n", GetCurrentThreadId());
				}) });

				return true;
			}
			
			pcap_close(handle);
		}

		return false;
	}

	bool Sniffer::send(Network::Interface* networkIf, std::string data)
	{
		std::lock_guard<std::mutex> _(this->mutex);

		bool res = false;
		char errbuf[PCAP_ERRBUF_SIZE];
		for (auto& _if : this->interfaces)
		{
			if (_if.handle == networkIf->handle)
			{
				pcap_t* handle = pcap_open(_if.name.data(), 100, PCAP_OPENFLAG_PROMISCUOUS, 1000, NULL, errbuf);
				if (handle)
				{
					if (!pcap_sendpacket(handle, reinterpret_cast<const u_char*>(data.data()), data.size())) res = true;
					pcap_close(handle);
				}

				break;
			}
		}

		if (!res)
		{
			printf("Failed to send packet!\n");
		}

		return res;
	}

	void Sniffer::onPacket(Callback _callback)
	{
		this->callback = _callback;
	}

	Sniffer::Sniffer()
	{
		this->openAllInterfaces();

		/*char errbuf[PCAP_ERRBUF_SIZE];
		char* defaultIf = pcap_lookupdev(errbuf);
		this->openInterface(defaultIf);*/
	}

	Sniffer::~Sniffer()
	{
		std::lock_guard<std::mutex> _(this->mutex);

		for (auto& iFace : this->interfaces)
		{
			pcap_breakloop(iFace.handle);

			if (iFace.thread.joinable())
			{
				iFace.thread.join();
			}

			pcap_close(iFace.handle);
		}
	}
}
