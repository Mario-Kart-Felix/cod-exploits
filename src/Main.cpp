#include "STDInclude.hpp"

#include <pcap.h>
#include "Extern/Huffman.hpp"

#include "Network/Address.hpp"
#include "Network/Socket.hpp"

#include "Core/OOBHandler.hpp"

/* 4 bytes IP address */
typedef struct ip_address
{
	u_char byte1;
	u_char byte2;
	u_char byte3;
	u_char byte4;
}ip_address;

/* IPv4 header */
typedef struct ip_header
{
	u_char	ver_ihl;		// Version (4 bits) + Internet header length (4 bits)
	u_char	tos;			// Type of service 
	u_short tlen;			// Total length 
	u_short identification; // Identification
	u_short flags_fo;		// Flags (3 bits) + Fragment offset (13 bits)
	u_char	ttl;			// Time to live
	u_char	proto;			// Protocol
	u_short crc;			// Header checksum
	ip_address	saddr;		// Source address
	ip_address	daddr;		// Destination address
	u_int	op_pad;			// Option + Padding
}ip_header;

/* UDP header*/
typedef struct udp_header
{
	u_short sport;			// Source port
	u_short dport;			// Destination port
	u_short len;			// Datagram length
	u_short crc;			// Checksum
}udp_header;

struct RefData
{
	Network::Address* target;
	pcap_t* _if;
};

void packetHandler(u_char *param, const struct pcap_pkthdr* /*header*/, const u_char *pkt_data)
{
	RefData* data = reinterpret_cast<RefData*>(param);

	ip_header* ih = (ip_header *)(pkt_data + 14);
	u_int ip_len = (ih->ver_ihl & 0xf) * 4;
	udp_header* uh = (udp_header *)((u_char*)ih + ip_len);

	if (data->target->getPort() == ntohs(uh->sport) || data->target->getPort() == ntohs(uh->dport))
	{
		data->target->getInAddr()->sin_addr.S_un.S_un_b.s_b1 = ih->saddr.byte1;
		data->target->getInAddr()->sin_addr.S_un.S_un_b.s_b2 = ih->saddr.byte2;
		data->target->getInAddr()->sin_addr.S_un.S_un_b.s_b3 = ih->saddr.byte3;
		data->target->getInAddr()->sin_addr.S_un.S_un_b.s_b4 = ih->saddr.byte4;

		if (data->target->isLocal())
		{
			data->target->getInAddr()->sin_addr.S_un.S_un_b.s_b1 = ih->daddr.byte1;
			data->target->getInAddr()->sin_addr.S_un.S_un_b.s_b2 = ih->daddr.byte2;
			data->target->getInAddr()->sin_addr.S_un.S_un_b.s_b3 = ih->daddr.byte3;
			data->target->getInAddr()->sin_addr.S_un.S_un_b.s_b4 = ih->daddr.byte4;

			if (data->target->isLocal())
			{
				return;
			}
		}

		pcap_breakloop(data->_if);
	}
}

Network::Address findTarget(unsigned short port)
{
	printf("Detecting target...\n");
	Network::Address target("127.0.0.1:1");
	target.setPort(port);
	target.getInAddr()->sin_family = AF_INET;

	pcap_if_t *alldevs;
	char errbuf[PCAP_ERRBUF_SIZE];
	if (pcap_findalldevs(&alldevs, errbuf) == 0)
	{
		std::vector<std::pair<pcap_t*, std::thread>> ifs;

		pcap_if_t* __if = alldevs;
		while (__if)
		{
			pcap_t* handle;

			if ((handle = pcap_open_live(__if->name, 65536, 1, 1000, errbuf)) != NULL)
			{
				if (pcap_datalink(handle) == DLT_EN10MB)
				{
					u_int netmask;

					if (__if->addresses != NULL) netmask = ((struct sockaddr_in *)(__if->addresses->netmask))->sin_addr.S_un.S_addr;
					else netmask = 0xffffff;

					ifs.push_back({ handle, std::thread{} });
				}
			}

			__if = __if->next;
		}

		pcap_freealldevs(alldevs);

		std::mutex mutex;
		std::atomic<bool> handled = false;

		for (auto& _if : ifs)
		{
			_if.second = std::thread([&]()
			{
				RefData data;
				data.target = &target;
				data._if = _if.first;

				pcap_loop(_if.first, 0, packetHandler, reinterpret_cast<u_char*>(&data));
				
				std::lock_guard<std::mutex> _(mutex);
				if (!handled)
				{
					handled = true;

					for (auto& __if : ifs)
					{
						if (__if.first != _if.first)
						{
							pcap_breakloop(__if.first);
						}
					}
				}

				pcap_close(_if.first);
			});
		}

		while (!handled)
		{
			std::this_thread::sleep_for(10ms);
		}

		mutex.lock();
		mutex.unlock();

		for (auto& _if : ifs)
		{
			if (_if.second.joinable())
			{
				_if.second.join();
			}
		}
	}

	char buffer[MAX_PATH] = { 0 };
	inet_ntop(target.getInAddr()->sin_family, &target.getInAddr()->sin_addr, buffer, sizeof(buffer));
	printf("Discovered %s:%d\n", buffer, target.getPort());

	return target;
}

std::string HuffmanCompressData(std::string data)
{
	Huffman_InitMain();

	Utils::Memory::Allocator allocator;
	byte* target = allocator.allocateArray<byte>(0x10000 + data.size() * 2);

	int size = MSG_WriteBitsCompress(0, reinterpret_cast<const byte*>(data.data()), target, data.size());
	return std::string(LPSTR(target), size);
}

int main(int argc, char** argv)
{
	Network::Socket s;
	Core::OOBHandler oobHandler;

	s.onData([&](Network::Address addr, std::string_view view)
	{
		if (oobHandler.handle(&s, addr, view))
		{
			//printf("Handled data %s\n", view.data());
		}
		else
		{
			//printf("Received data %s\n", view.data());
		}
	});

	std::string addressString = "127.0.0.1:28960";
	if (argc > 1) addressString = argv[1];

	Network::Address addr(addressString);
	if (argc <= 1) addr = findTarget(28960);

	/*oobHandler.connect(&s, addr, [](Network::Socket* sock, Network::Address addr)
	{
		Utils::Buffer buffer;
		buffer.write<int>(-2);  // Magic
		buffer.write<int>(1); // Magic seems to get cut off :(
		buffer.write<short>(0); // qport

		buffer.write<char>(0);
		buffer.write<int>(0);
		buffer.write<int>(0);

		std::string data = "Hallo";
		std::string compr = HuffmanCompressData(data);
		buffer.append(compr);

		//buffer.resize(0x1000);
		sock->send(addr, buffer);
	});*/
	s.send(addr, OOB_MAGIC "relay 1234567890");

	_getch();

	return 0;
}
