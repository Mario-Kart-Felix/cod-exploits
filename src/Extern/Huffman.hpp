#pragma once

typedef unsigned char byte;
typedef DWORD _DWORD;
typedef bool qboolean;

typedef struct {
	qboolean	allowoverflow;	// if false, do a Com_Error
	qboolean	overflowed;		// set to true if the buffer size failed (with allowoverflow set)
	qboolean	oob;			// set to true if the buffer size failed (with allowoverflow set)
	byte	*data;
	int		maxsize;
	int		cursize;
	int		readcount;
	int		bit;				// for bitwise reads and writes
} msg_t;

#define NYT HMAX                    /* NYT = Not Yet Transmitted */
#define INTERNAL_NODE ( HMAX + 1 )

typedef struct nodetype {
	struct  nodetype *left, *right, *parent; /* tree structure */
											 //	struct  nodetype *next, *prev; /* doubly-linked list */
											 //	struct  nodetype **head; /* highest ranked node in block */
	int weight;
	int symbol; //0x10
				//	struct  nodetype *next, *prev; /* doubly-linked list */
				//	struct  nodetype **head; /* highest ranked node in block */

} node_t; //Length: 20

#define HMAX 256 /* Maximum symbol */

typedef struct {
	int blocNode;
	int blocPtrs;

	node_t*     tree;
	node_t*     loc[HMAX + 1];
	node_t**    freelist;

	node_t nodeList[768];
	node_t*     nodePtrs[768];

} huff_t;
/* size 19476*/

int MSG_ReadBitsCompress(const byte* input, int readsize, byte* outputBuf, int outputBufsize);
int MSG_WriteBitsCompress(char dummy, const byte *datasrc, byte *buffdest, int bytecount);
void Huffman_InitMain();

#define Com_Memcpy memcpy
#define Com_Memset memset
