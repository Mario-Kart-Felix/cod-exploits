#include "STDInclude.hpp"

#include "Network/Address.hpp"
#include "Network/Sniffer.hpp"

#include "Game/MW2/Handler.hpp"
#include "Game/MW2/Client.hpp"

namespace Game
{
	namespace MW2
	{
		Client::Client(Handler* _handler, uint64_t _xuid, Network::Address _target) : handler(_handler), xuid(_xuid), target(_target)
		{
			printf("Connecting to party at %s with xuid %llX\n", this->target.toString().data(), this->xuid);

			this->onOOB("connect", [this](Network::Sniffer* /*sniffer*/, pcap_t* /*networkIf*/, std::string data, bool receiving)
			{
				static std::regex infoStringRegex("([0-9a-fA-F]*) \"(.*)\"");

				if (!receiving)
				{
					std::smatch match;
					if (std::regex_search(data, match, infoStringRegex) && match.size() >= 3)
					{
						Utils::InfoString info(match[2]);
						this->qport = USHORT(atoi(info.get("qport").data()));

						printf("Connecting as %s\n", info.get("name").data());
					}
				}
			});

			this->onOOB("connectResponse", [this](Network::Sniffer* /*sniffer*/, pcap_t* /*networkIf*/, std::string /*data*/, bool receiving)
			{
				if (receiving)
				{
					printf("Connected to server!\n");
				}
			});
		}

		Client::~Client()
		{

		}

		void Client::onOOB(std::string command, Callback callback)
		{
			this->oobHandlers[Utils::String(command).toLower()] = callback;
		}

		void Client::send(std::string data)
		{
			if (this->packetTemplate.empty()) return;

			Utils::Buffer buffer(this->packetTemplate);
			PBYTE buf = PBYTE(buffer.data());

			const ipHeader* ih = reinterpret_cast<const ipHeader *>(buf + sizeof(ethHeader));

			u_int ipLen = (ih->ver_ihl & 0xF) * 4;
			udpHeader* uh = reinterpret_cast<udpHeader *>(PBYTE(ih) + ipLen);
		}

		int Client::getDirection(Network::Address source, Network::Address _target)
		{
			if (source == this->target) return Client::PacketDirection::REMOTE_TO_LOCAL;
			if (_target == this->target) return Client::PacketDirection::LOCAL_TO_REMOTE;

			return Client::PacketDirection::NONE;
		}

		void Client::handle(Network::Sniffer* sniffer, pcap_t* networkIf, std::string_view data, std::string_view rawData, bool receiving)
		{
			if (!receiving && this->packetTemplate.empty())
			{
				this->packetTemplate = rawData.substr(0, rawData.size() - data.size());
			}

			if (!this->handleOOB(sniffer, networkIf, data, receiving))
			{
				this->handleNetchan(sniffer, networkIf, data, receiving);
			}
		}

		bool Client::handleOOB(Network::Sniffer* sniffer, pcap_t* networkIf, std::string_view data, bool receiving)
		{
			if (data.size() >= 4 && !std::memcmp(data.data(), "\xFF\xFF\xFF\xFF", 4))
			{
				Utils::String command;
				for (auto i = data.begin() + 4; i != data.end(); ++i)
				{
					if (*i == '\0' || *i == '\n' || *i == ' ' || (i + 1) == data.end())
					{
						command = std::string(data.begin() + 4, i);
						break;
					}
				}

				std::string buffer;
				if (data.size() >= command.size() + 5)
				{
					buffer = std::string(data.begin() + command.size() + 5, data.end());
				}

				auto callback = this->oobHandlers.find(command.toLower());
				if (callback != this->oobHandlers.end())
				{
					callback->second(sniffer, networkIf, buffer, receiving);
				}

				return true;
			}

			return false;
		}

		void Client::handleNetchan(Network::Sniffer* sniffer, pcap_t* networkIf, std::string_view data, bool receiving)
		{
			// TODO Keep track of the natchan state
			sniffer; networkIf; data; receiving;
		}
	}
}
